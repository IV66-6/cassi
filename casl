#!/usr/bin/env python3
#
# A simple implementation of CASL assembler.
# Copyright (c) 1997-2000, Hiroyuki Ohsaki.
# All rights reserved.
#

import collections
import os
import os.path
import re
import struct
import sys

from perlcompat import die, warn, getopts
import tbdump

VERSION = 0.1
DEBUG = False

# addresses of IN/OUT/EXIT system calls --- these MACROs are expanded
# to call this address after pushing its arguments on stack.
SYS_IN = 0xfff0
SYS_OUT = 0xfff2
SYS_EXIT = 0xfff4

Inst = collections.namedtuple('Inst', ['type', 'code'])

# COMET instructions
# All valid instructions must have an entry in this hash.  CODE is the
# object code of the instruction, and TYPE is the type of instruction
# (e.g., ``op1'' indicates it takes two or three operands).
INSTTBL = {
    'LD': Inst('op1', 0x10),
    'ST': Inst('op1', 0x11),
    'LEA': Inst('op1', 0x12),
    'ADD': Inst('op1', 0x20),
    'SUB': Inst('op1', 0x21),
    'AND': Inst('op1', 0x30),
    'OR': Inst('op1', 0x31),
    'EOR': Inst('op1', 0x33),
    'CPA': Inst('op1', 0x40),
    'CPL': Inst('op1', 0x41),
    'SLA': Inst('op1', 0x50),
    'SRA': Inst('op1', 0x51),
    'SLL': Inst('op1', 0x52),
    'SRL': Inst('op1', 0x53),
    'JPZ': Inst('op2', 0x60),
    'JMI': Inst('op2', 0x61),
    'JNZ': Inst('op2', 0x62),
    'JZE': Inst('op2', 0x63),
    'JMP': Inst('op2', 0x64),
    'PUSH': Inst('op2', 0x70),
    'POP': Inst('op3', 0x71),
    'CALL': Inst('op2', 0x80),
    'RET': Inst('op4', 0x81),
    # pseudo instructions
    'START': Inst('start', None),
    'END': Inst('end', None),
    'DS': Inst('ds', None),
    'DC': Inst('dc', None),
    # CASL macros
    'IN': Inst('in', None),
    'OUT': Inst('out', None),
    'EXIT': Inst('exit', None),
}

def usage():
    die(f"""\
usage: {sys.argv[0]} [-av] file...
 -a          turn on verbose listings
 -v          display version and exit
""")

# global variables for string the currently processing file and the line number.
__file = None
__lineno = None

def debug(msg):
    if DEBUG:
        warn(f'** {__file}:{__lineno}: {msg}')

def error(msg):
    die(f'{__file}:{__lineno}: {msg}')

def parse_number(v):
    if type(v) == int:
        return int(v) & 0xffff
    elif type(v) == str:
        if re.search(r'^[-+]?\d+$', v):
            return int(v) & 0xffff
        else:
            m = re.search(r'^#([\da-zA-Z]+)$', v)
            if m:
                # convert hex to decimal
                return int(m.group(1), base=16) & 0xffff
    return None

def check_decimal(number):
    """Check the validity of decimal number NUMBER.  If not valid, display
error and exit."""
    debug(f'check_decimal({number})')
    if not re.search(r'^[+-]?\d+$', number):
        error(f"'{number}' must be decimal")
    return int(number)

# ----------------------------------------------------------------
class LabelTable:
    def __init__(self):
        self.tbl = {}
        self.location = {}

    def __repr__(self):
        return 'LabelTable()'

    def __setitem__(self, label, val):
        self.tbl[label] = val
        self.location[label] = '__file, __lineno'

    def __getitem__(self, label):
        return self.tbl[label]

    def check_label(self, label):
        """Check the validity of label LABEL.  If not valid, display error and
        exit."""
        debug(f'check_label({self}, {label})')
        if not re.search(r'^[A-Z][0-9A-Za-z]{0,5}$', label):
            error(f"invalid label '{label}'")

    def register(self, label, val):
        """Register a label LABEL in the label table with the value
        VAL.  If LABEL is already defined, display error and exit."""
        debug(f'register({self}, {label}, {val})')
        self.check_label(label)
        if label in self.tbl:
            error(f"label '{label}' already defined")
        self[label] = val

    def expand(self, val):
        """Expand VAL to the corresponding decimal number.  Any label is
        resolved and hexadecimal number is converted to decimal."""
        debug(f'expand({self}, {val})')
        if type(val) == str:
            if val in self.tbl:
                val = self[val]
        v = parse_number(val)
        if v is None:
            error(f"undefined label '{val}'")
        return v

class Memory:
    def __init__(self):
        self.memory = []
        self.src = []

    def __repr__(self):
        return 'Memory()'

    def __setitem__(self, addr, val):
        size = len(self.memory)
        if size < addr + 1:
            self.memory.extend([None] * (addr + 1 - size))
        self.memory[addr] = val

    def __getitem__(self, addr):
        return self.memory[addr]

    def set_src_at(self, addr, line):
        size = len(self.src)
        if size < addr + 1:
            self.src.extend([None] * (addr + 1 - size))
        self.src[addr] = 'foo', 123, line

    def get_src_at(self, addr):
        return self.src[addr]

    def _register_number(self, reg):
        """Check the validity of register REG.  Return the register
        number (0 - 4). If not valid, display error and exit."""
        debug(f'_register_number({self}, {reg})')
        if reg is None:
            return 0
        m = re.search(r'^GR([0-4])$', reg)
        if not m:
            error(f"invalid register '{reg}'")
        return int(m.group(1))

    def generate_code(self, addr, inst, gr, adr, xr):
        """Generate two-word code from INST, GR, ADR, and XR at ADDRESS."""
        debug(
            f'generate_code({self}, {addr:04x}, {inst:02x}, {gr}, {adr}, {xr})'
        )
        gr = self._register_number(gr)
        xr = self._register_number(xr)
        val = (inst << 8) + (gr << 4) + xr
        self[addr] = val
        self[addr + 1] = adr

# ----------------------------------------------------------------
def remove_comment(line):
    # remove comment --- take care of ``;'' between single quotes.
    m = re.search(r"(^[^;]*'[^']*'.*?);.*$", line)
    if m:
        line = m.group(1)
    line = re.sub(r';.*$', '', line)
    # remove trailing spaces
    line = re.sub(r'\s+$', '', line)
    return line

def _pass1(labeltbl, memory, in_block, addr, label, inst, opr):
    if not inst in INSTTBL:
        error(f"illegal instruction '{inst}'")
    type_ = INSTTBL[inst].type
    code = INSTTBL[inst].code
    if opr:
        oprs = re.split(r'[,\s]+', opr)
        noprs = len(oprs)
    else:
        oprs = None, None, None
        noprs = 0
    while len(oprs) < 3:
        oprs.append(None)

    # START must be the first instruction
    if not in_block and type_ != 'start':
        error(f"no START macro found")

    # GR0 cannot be used as an index register.
    if noprs >= 3 and re.search(r'^(GR)?0$', oprs[2]):
        error("can't use GR0 as an index register")

    # instructions with GR, adr, and optional XR
    if type_ == 'op1':
        if not (2 <= noprs <= 3):
            error(f"missing operands '{oprs}'")
        memory.generate_code(addr, code, *oprs)
        addr += 2
    # instructions with adr, and optional XR
    elif type_ == 'op2':
        if not (1 <= noprs <= 2):
            error(f"too much/too many operand '{oprs}'")
        memory.generate_code(addr, code, None, oprs[0], oprs[1])
        addr += 2

    # instructions only with optional GR
    elif type_ == 'op3':
        if noprs != 1:
            error(f"expects just one operand '{oprs}'")
        memory.generate_code(addr, code, oprs[0], None, None)
        addr += 2

    # instructions without operand
    elif type_ == 'op4':
        if noprs > 0:
            error(f'invalid operand "{oprs}"')
        memory.generate_code(addr, code, oprs[0], None, None, None)
        addr += 2

    # START instruction
    elif type_ == 'start':
        if not label:
            error("no label found at START")
        # FIXME: memory[-1] = oprs[0] if len(oprs) else 0
        in_block = 1

    # END instruction
    elif type_ == 'end':
        if label:
            error("can't use label '{label}' at END")
        if noprs > 0:
            error(f"END accepts no operand '{oprs}'")
        in_block = 0

    # DS instruction
    elif type_ == 'ds':
        if noprs != 1:
            error(f"DS exepects a single operand '{oprs}'")
        v = check_decimal(oprs[0])
        for n in range(v):
            memory[addr] = 0
            addr += 1

    # DC instruction
    elif type_ == 'dc':
        m = re.search(r"^'([^\']+)'$", opr)
        if m:
            vals = bytearray(m.group(1), encoding='utf-8')
            for _ in vals:
                memory[addr] = _
                addr += 1
        elif noprs == 1:  # number or label
            memory[addr] = oprs[0]
            addr += 1
        else:
            error(f"DC accepts a word count or a string '{oprs}'")

    # IN/OUT macro
    elif type_ == 'in' or type_ == 'out':
        if noprs != 2:
            error(f"IN/OUT macro requires two operands '{oprs}'")
        # two operands must be labels, not numbers
        labeltbl.check_label(oprs[0])
        labeltbl.check_label(oprs[1])
        # IN/OUT macro is expanded to push two operands onto the
        # stack, call SYS_IN / SYS_OUT, and restore stack.
        entry = SYS_IN if type_ == 'in' else SYS_OUT
        memory.generate_code(addr + 2, INSTTBL['PUSH'].code, None, oprs[1],
                             None)
        memory.generate_code(addr + 4, INSTTBL['CALL'].code, None, entry, None)
        memory.generate_code(addr + 6, INSTTBL['LEA'].code, 'GR4', 2, 'GR4')
        addr += 8

    # EXIT macro
    elif type_ == 'exit':
        if noprs > 0:
            error(f"EXIT does not accept operand '{oprs}'")
        # EXIT macro is replaced with 'JMP SYS_EXIT'
        memory.generate_code(addr, INSTTBL['JMP'].code, None, SYS_EXIT, None)
        addr += 2
    else:
        error(f"instruction type '{type_}' not implemented")
    return in_block, addr

def pass1(file, labeltbl, memory):
    """Parse the source file FILE, register all symbols to LABELTBL, and
    generate code in MEMORY."""
    with open(file) as f:
        global __file
        __file = file
        global __lineno
        addr = 0
        in_block = None
        for __lineno, line in enumerate(f):
            line = line.rstrip()
            debug(line)
            line = remove_comment(line)
            # skip to next line if neither label nor instruction is specified
            if line == '':
                continue

            # extract fields
            m = re.search(r'^(\S+)?\s+([A-Z]+)(\s+(.*)?)?$', line)
            if m:
                label, inst, opr = m.group(1), m.group(2), m.group(4)
                debug(f'label/inst/opr = {label}/{inst}/{opr}')
            else:
                error('syntax error')

            # register label to the symbol table
            if label:
                labeltbl.register(label, addr)
            # generate object code according the type of instruction
            if inst:
                in_block, addr = _pass1(labeltbl, memory, in_block, addr,
                                        label, inst, opr)
        if in_block:
            error("No 'END' instruction found")

def pass2(file, labeltbl, memory, show_listing):
    """Open the output file, and dump the assembled object code."""
    base = os.path.basename(file)
    outfile = f'{base}.com'
    with open(outfile, 'wb') as f:
        # print object header
        f.write(struct.pack('4sn10x', b'CASL', 0x0000))  # FIXME: use label
        # dump memory image
        if show_listing:
            print('CASL LISTING file')
        last_lineno = None
        for addr, val in enumerate(memory):
            val = labeltbl.expand(val)
            f.write(struct.pack('>H', val))
            if show_listing:
                file, lineno, line = memory.get_src_at(addr)
                if lineno != last_lineno:
                    print(f'{lineno:4} {addr:04x} {val:04x} ', end='')
                    print(line)
                    last_lineno = lineno
                else:
                    print(f'{lineno:4}      {val:04x}')

def dump_labels(labeltbl):
    print('\nDEFINED LABELS')
    for label in labeltbl:
        print(
            f'\t{labeltbl[label].file}:{labeltbl[label].line}:\t{labeltbl[label].val:04x}\t{label}'
        )

def parse_options(opt):
    if opt.v:
        print(f"This is CASL, version {VERSION}.\n"
              "Copyright (c) 2021, Hiroyuki Ohsaki.\n"
              "All rights reserved.")
        sys.exit(1)
    if opt.d:
        global DEBUG
        DEBUG = True

def main():
    opt = getopts('avd') or usage()
    parse_options(opt)
    show_listing = opt.a
    for file in sys.argv[1:]:
        memory = Memory()
        labeltbl = LabelTable()
        pass1(file, labeltbl, memory)
        pass2(file, labeltbl, memory, show_listing)
        # list all labels
        if show_listing:
            dump_labels(labeltbl)

if __name__ == "__main__":
    main()
