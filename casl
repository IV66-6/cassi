#!/usr/bin/env python3
#
# A simple implementation of CASL assembler.
# Copyright (c) 1997-2000, Hiroyuki Ohsaki.
# All rights reserved.
#

import collections
import os
import os.path
import re
import struct
import sys

from perlcompat import die, warn, getopts
import tbdump

Inst = collections.namedtuple('Inst', ['type', 'code'])
Label = collections.namedtuple('Label', ['val', 'file', 'line'])
Word = collections.namedtuple('Word', ['val', 'file', 'line'])

# All valid instructions must have an entry in this hash.  CODE is the
# object code of the instruction, and TYPE is the type of instruction
# (e.g., ``op1'' indicates it takes two or three operands).
INSTTBL = {# COMET instructions
               'LD'    : Inst('op1', 0x10),
               'ST'    : Inst('op1', 0x11),
               'LEA'   : Inst('op1', 0x12),
               'ADD'   : Inst('op1', 0x20),
               'SUB'   : Inst('op1', 0x21),
               'AND'   : Inst('op1', 0x30),
               'OR'    : Inst('op1', 0x31),
               'EOR'   : Inst('op1', 0x33),
               'CPA'   : Inst('op1', 0x40),
               'CPL'   : Inst('op1', 0x41),
               'SLA'   : Inst('op1', 0x50),
               'SRA'   : Inst('op1', 0x51),
               'SLL'   : Inst('op1', 0x52),
               'SRL'   : Inst('op1', 0x53),
               'JPZ'   : Inst('op2', 0x60),
               'JMI'   : Inst('op2', 0x61),
               'JNZ'   : Inst('op2', 0x62),
               'JZE'   : Inst('op2', 0x63),
               'JMP'   : Inst('op2', 0x64),
               'PUSH'  : Inst('op2', 0x70),
               'POP'   : Inst('op3', 0x71),
               'CALL'  : Inst('op2', 0x80),
               'RET'   : Inst('op4', 0x81),
               # pseudo instructions
               'START' : Inst('start', None),
               'END'   : Inst('end',None),
               'DS'    : Inst('ds' ,None),
               'DC'    : Inst('dc' ,None),
               # CASL macros
               'IN'    : Inst('in'   ,None),
               'OUT'   : Inst('out'  ,None),
               'EXIT'  : Inst('exit' ,None),
               }

# addresses of IN/OUT/EXIT system calls --- these MACROs are expanded
# to call this address after pushing its arguments on stack.
SYS_IN = 0xfff0
SYS_OUT = 0xfff2
SYS_EXIT = 0xfff4

VERSION = 0.1
DEBUG = 0

# global variables of currently processing file and line number.
# These variables are used in &error.
__file = None
__line = None

def usage():
    die(f"""\
usage: {sys.argv[0]} [-av] file...
 -a          turn on verbose listings
 -v          display version and exit
""")

def debug(msg):
    if DEBUG:
        warn(f'{__file}:{__line}: {msg}')

def error(msg):
    die(f'{__file}:{__line}: {msg}')

# Check the validity of label LABEL.  If not valid, display error and
# exit.
def check_label(label):
    debug(f'check_label({label})')
    if not re.search(r'^[A-Z][0-9A-Za-z]{0,5}$', label):
        error(f'invalid label "{label}"')

# Register a label LABEL in the symbol table HASHREF with the value
# VAL.  If LABEL is already defined, display error and exit.
def add_label(tbl, label, val):
    check_label(label)
    if label in tbl:
        error(f'label "{label}" already defined')
    tbl[label] = Label(val, __file, __line)

# Expand the string VAL to corresponding decimal number --- symbol is
# resolved and hexadecimal number is converted to decimal.
def expand_label(tbl, val):
    debug(f'expand_label(tbl, {val})')
    if type(val) == str:
        m = re.search(r'^\#([\da-f]+)', val, flags=re.I)
        if m:
            val = int(m.group(1), 16)  # convert hex to decimal
        elif val in tbl:
            val = tbl[val].val
        elif not re.search(r'^[+-]?\d+$', val):
            error(f'undefined symbol "{val}"')
        else:
            val = int(val)
    val &= 0xffff
    return val

# Check the validity of decimal number NUMBER.  If not valid, display
# error and exit.
def check_decimal(number):
    debug(f'check_decimal({number})')
    if not re.search(r'^[+-]?\d+$', number):
        error(f'"{number}" must be decimal')
    return int(number)

# Check the validity of register REGISTER.  Return the register number
# (0 - 4). If not valid, display error and exit.  Otherwise,
def check_register(register):
    debug(f'check_register({register})')
    if register is None:
        return 0
    m = re.search(r'^(GR)([0-4])$', register)
    if not m:
        error(f'invalid register "{register}"')
    return int(m.group(2))

# Generate a one-byte code of VAL at ADDRESS in MEMORY.
def gen_code1(memory, address, val):
    debug(f'gen_code1(memory, {address:04x}, {val})')
    memory[address] = Word(val, __file, __line)

# Generate two-byte codes from CODE, GR, ADR, and XR at ADDRESS in
# MEMORY.
def gen_code2(memory, address, code, gr, adr, xr):
    gr = check_register(gr)
    xr = check_register(xr)
    val = (code << 8) + (gr << 4) + xr
    address += 1
    gen_code1(memory, address, val)
    address += 1
    gen_code1(memory, address, adr)

def _pass1(symtbl, memory, buf, in_block, address, label, inst, opr):
    # register label to the symbol table
    if label:
        add_label(symtbl, label, address)

    # generate object code according the type of instruction
    if inst:
        if not inst in INSTTBL:
            error(f'illegal instruction "{inst}"')

        type_ = INSTTBL[inst].type
        if opr:
            oprs = re.split(r'[,\s]+', opr)
            noprs = len(oprs)
        else:
            oprs = None, None, None
            noprs = 0
        while len(oprs) < 3:
            oprs.append(None)

        # START must be the first instruction
        if not in_block and type_ != 'start':
            error(f'No "START" instruction found')

        # GR0 cannot be used as an index register.
        if oprs[2] and re.search(r'^(GR)?0$', oprs[2]):
            error("Can't use GR0 as an index register")

        # instructions with GR, adr, and optional XR
        if type_ == 'op1':
            if not (2 <= noprs <= 3):
                error(f'invalid operand {oprs}')
            gen_code2(memory, address, INSTTBL[inst].code, oprs[0], oprs[1],
                      oprs[2])
            address += 2

        # instructions with adr, and optional XR
        elif type_ == 'op2':
            if not (1 <= noprs <= 2):
                error(f'invalid operand {oprs}')
            gen_code2(memory, address, INSTTBL[inst].code, None, oprs[0],
                      oprs[1])
            address += 2

        # instructions only with optional GR
        elif type_ == 'op3':
            if noprs != 1:
                error(f'invalid operand "{oprs}"')
            gen_code2(memory, address, INSTTBL[inst].code, oprs[0], None, None)
            address += 2

        # instructions without operand
        elif type_ == 'op4':
            if noprs > 0:
                error(f'invalid operand "{oprs}"')
            gen_code2(memory, address, INSTTBL[inst].code, None, None, None)
            address += 2

        # START instruction
        elif type_ == 'start':
            if not label:
                error('no label found at START')
            # FIXME: memory[-1] = oprs[0] if len(oprs) else 0
            in_block = 1

        # END instruction
        elif type_ == 'end':
            if label:
                error('can\'t use label "{label}" at END')
            if noprs > 0:
                error(f'invalid operand "{oprs}"')
            in_block = 0

        # DS instruction
        elif type_ == 'ds':
            if noprs != 1:
                error(f'invalid operand "{oprs}"')
            v = check_decimal(oprs[0])
            for n in range(v):
                gen_code1(memory, address, 0)
                address += 1

        # DC instruction
        elif type_ == 'dc':
            m = re.search(r"^'([^\']+)'$", opr)
            if m:
                vals = bytearray(m.group(1), encoding='utf-8')
                for _ in vals:
                    gen_code1(memory, address, _)
                    address += 1
            elif noprs == 1:  # number or label
                gen_code1(memory, address, oprs[0])
                address += 1
            else:
                error(f'invalid operand "{oprs}"')

        # IN/OUT macro
        elif type_ == 'in' or type_ == 'out':
            if noprs != 2:
                error(f'invalid operand "{oprs}"')
            # two operands must be labels, not numbers
            check_label(oprs[0])
            check_label(oprs[1])
            # IN/OUT macro is expanded to push two operands onto the
            # stack, call SYS_IN / SYS_OUT, and restore stack.
            entry = SYS_IN if type_ == 'in' else SYS_OUT
            gen_code2(memory, address, INSTTBL['PUSH'].code, None, oprs[0],
                      None)
            gen_code2(memory, address + 2, INSTTBL['PUSH'].code, None, oprs[1],
                      None)
            gen_code2(memory, address + 4, INSTTBL['CALL'].code, None, entry,
                      None)
            gen_code2(memory, address + 6, INSTTBL['LEA'].code, 'GR4', 2,
                      'GR4')
            address += 8

        # EXIT macro
        elif type_ == 'exit':
            if noprs > 0:
                error(f'invalid operand "{oprs}"')
            # EXIT macro is replaced with 'JMP SYS_EXIT'
            gen_code2(memory, address, INSTTBL['JMP'].code, None, SYS_EXIT,
                      None)
            address += 2
        else:
            error(f'instruction type "{type_}" is not implemented')
    return in_block, address

# Parse the source file FILE, register all symbols to SYMTBL,
# and generate code in MEMORY.
def pass1(file, symtbl, memory, buf):
    with open(file) as f:
        address = 0
        global __line
        in_block = None
        for __line, line in enumerate(f):
            line = line.rstrip()
            debug(f'{__line}: {line}')

            # remove comment --- take care of ``;'' between single quotes.
            m = re.search(r"(^[^;]*'[^']*'.*?);.*$", line)
            if m:
                line = m.group(1)
            line = re.sub(r';.*$', '', line)
            # remove trailing spaces
            line = re.sub(r'\s+$', '', line)
            # skip to next line if neither label nor instruction is specified.
            if line == '':
                continue

            # extract each field
            m = re.search(r'^(\S+)?\s+([A-Z]+)(\s+(.*)?)?$', line)
            if m:
                label, inst, opr = m.group(1), m.group(2), m.group(4)
                debug(f'label/inst/opr = {label}/{inst}/{opr}')
            else:
                error('syntax error')

            # store every line in BUF for later use
            buf[__line] = f'{label or " "}\t{inst}\t{opr}'

            in_block, address = _pass1(symtbl, memory, buf, in_block, address,
                                       label, inst, opr)
        if in_block:
            error('no "END" instruction found')

# Open the output file, and dump the assembled object code.
def pass2(file, symtbl, memory, buf):
    base = os.path.basename(file)
    outfile = f'{base}.com'
    with open(outfile, 'wb') as f:
        # print object header
        f.write(struct.pack('4sn10x', b'CASL', 0x0000))  # FIXME: use label
        # dump memory image
        if opt.a:
            print('CASL LISTING file')
        last_line = None
        for address in sorted(memory.keys()):
            val = expand_label(symtbl, memory[address].val)
            f.write(struct.pack('n', val))
            __line = memory[address].line

            if opt.a:
                if __line != last_line:
                    print(f'{__line:4} {address:04x} {val:04x} ', end='')
                    print(buf[__line])
                    last_line = __line
                else:
                    print(f'{__line:4}      {val:04x}')

        # list all symbols
        if opt.a:
            print('\nDEFINED SYMBOLS')
            for label in symtbl.keys():
                print(
                    f'\t{symtbl[label].file}:{symtbl[label].line}:\t{symtbl[label].val:04x}\t{label}'
                )

def main():
    global opt
    opt = getopts('av') or usage()
    if opt.v:
        print(f"This is CASL, version {VERSION}.\n"
              "Copyright (c) 2021, Hiroyuki Ohsaki.\n"
              "All rights reserved.")
        sys.exit(1)
    for file in sys.argv[1:]:
        memory = {}
        symtbl = {}
        buf = {}
        global __file
        __file = file
        pass1(file, symtbl, memory, buf)
        pass2(file, symtbl, memory, buf)

if __name__ == "__main__":
    main()
